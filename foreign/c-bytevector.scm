(define endianness (cond-expand (big-endian 'big) (else 'little)))

;; Code from (r6rs bytevectors) library begin. It is heavily modified
;;; Copyright 2015 William D Clinger.
;;;
;;; Permission to copy this software, in whole or in part, to use this
;;; software for any lawful purpose, and to redistribute this software
;;; is granted subject to the restriction that all copies made of this
;;; software must include this copyright and permission notice in full.
;;;
;;; I also request that you send me a copy of any improvements that you
;;; make to this software so that they may be incorporated within it to
;;; the benefit of the Scheme community.
;;;
(define-syntax unspecified (syntax-rules () ((_) (if #f #f))))
(define-syntax bytevector-div (syntax-rules () ((_ x y) (quotient x y))))
(define-syntax bytevector-mod (syntax-rules () ((_ x y) (remainder x y))))

(define two^48 (expt 2 48))
(define two^40 (expt 2 40))
(define two^32 (expt 2 32))
(define two^24 (expt 2 24))
(define two^16 (expt 2 16))

(define (c-bytevector-uint-set! cbv index val size)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-uint-set!: cbv must be c-bytevector" cbv))
  (cond ((symbol=? endianness 'little)
         (do ((i 0 (+ i 1)) (val val (bytevector-div val 256)))
           ((>= i size) (unspecified))
           (c-u8-set! (c-bytevector-pointer cbv) (+ index i) (bytevector-mod val 256))))
        ((symbol=? endianness 'big)
         (do ((i (- size 1) (- i 1)) (val val (bytevector-div val 256)))
           ((< i 0) (unspecified))
           (c-u8-set! (c-bytevector-pointer cbv) (+ index i) (bytevector-mod val 256))))
        (else (error "Unknown endianness" endianness))))


(define (c-bytevector-sint-set! cbv index val size)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-sint-set!: cbv must be c-bytevector" cbv))
  (let ((uval (if (< val 0) (+ val (expt 256 size)) val)))
    (c-bytevector-uint-set! cbv index uval size)))

(define (c-bytevector-uint-ref cbv index size)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-uint-ref: cbv must be c-bytevector" cbv))
  (cond ((symbol=? endianness 'little)
         (do ((i (- size 1) (- i 1))
              (result 0 (+ (* 256 result)
                           (c-u8-ref (c-bytevector-pointer cbv) (+ index i)))))
           ((< i 0)
            result)))
        ((symbol=? endianness 'big)
         (do ((i 0 (+ i 1))
              (result 0 (+ (* 256 result)
                           (c-u8-ref (c-bytevector-pointer cbv) (+ index i)))))
           ((>= i size)
            result)))
        (else (error "Unknown endianness" endianness))))

(define (c-bytevector-sint-ref cbv index size)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-sint-ref: cbv must be c-bytevector" cbv))
  (let* ((high-byte (c-u8-ref (c-bytevector-pointer cbv) (if (eq? endianness 'big) index (+ index size -1))))
         (uresult (c-bytevector-uint-ref cbv index size)))
    (if (> high-byte 127) (- uresult (expt 256 size)) uresult)))

(define bytevector-single-maxexponent 255)
(define bytevector-single-bias (bytevector-div bytevector-single-maxexponent 2))
(define bytevector-single-hidden-bit (expt 2 23))

(define bytevector-double-maxexponent 2047)
(define bytevector-double-bias (bytevector-div bytevector-double-maxexponent 2))
(define bytevector-double-hidden-bit (expt 2 52))    ; must be exact integer

(define (bytevector-normalized-ieee-parts p q)
  (cond ((< p q)
         (do ((p p (+ p p))
              (e 0 (- e 1)))
             ((>= p q)
              (values e p q))))
        ((<= (+ q q) p)
         (do ((q q (+ q q))
              (e 0 (+ e 1)))
             ((< p (+ q q))
              (values e p q))))
        (else
         (values 0 p q))))

(define (bytevector-ieee-parts x bias q)
  (cond ((nan? x)
         (values 0 (+ bias bias 1) (- q 1)))
        ((infinite? x)
         (values (if (positive? x) 0 1) (+ bias bias 1) 0))
        ((zero? x)
         (values (if (eqv? x -0.0) 1 0) 0 0))
        (else
         (let* ((sign (if (negative? x) 1 0))
                (y (exact (abs x)))
                (num (numerator y))
                (den (denominator y)))
           (call-with-values
            (lambda () (bytevector-normalized-ieee-parts num den))
            (lambda (exponent num den)
              (let ((biased-exponent (+ exponent bias)))
                (cond ((< 0 biased-exponent (+ bias bias 1))
                       ; within the range of normalized numbers
                       (if (<= den q)
                           (let* ((factor (/ q den))
                                  (num*factor (* num factor)))
                             (if (integer? factor)
                                 (values sign biased-exponent num*factor)
                                 (error 'bytevector-ieee-parts
                                        "this shouldn't happen: " x bias q)))
                           (let* ((factor (/ den q))
                                  (num*factor (/ num factor)))
                             (values sign
                                     biased-exponent
                                     (round num*factor)))))
                      ((>= biased-exponent (+ bias bias 1))
                       ; infinity
                       (values (if (positive? x) 0 1) (+ bias bias 1) 0))
                      (else
                       ; denormalized
                       ; FIXME: this has the double rounding bug
                       (do ((biased biased-exponent (+ biased 1))
                            (num (round (/ (* q num) den))
                                 (round (bytevector-div num 2))))
                           ((and (< num q) (= biased 1))
                            (values sign biased num))))))))))))

(define (c-bytevector-ieee-single-set! cbv k x)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-ieee-single-set!: cbv must be c-bytevector" cbv))
  (let ((pointer (c-bytevector-pointer cbv)))
    (call-with-values
      (lambda ()
        (bytevector-ieee-parts x bytevector-single-bias bytevector-single-hidden-bit))
      (lambda (sign biased-exponent frac)
        (define (store! sign biased-exponent frac)
          (cond
            ((eq? 'big endianness)
             (c-u8-set! pointer (+ k 0) (+ (* 128 sign) (bytevector-div biased-exponent 2)))
             (c-u8-set! pointer (+ k 1) (+ (* 128 (bytevector-mod biased-exponent 2)) (bytevector-div frac (* 256 256))))
             (c-u8-set! pointer (+ k 2) (bytevector-div (bytevector-mod frac (* 256 256)) 256))
             (c-u8-set! pointer (+ k 3) (bytevector-mod frac 256)))
            (else
              (c-u8-set! pointer (+ k 3) (+ (* 128 sign) (bytevector-div biased-exponent 2)))
              (c-u8-set! pointer (+ k 2) (+ (* 128 (bytevector-mod biased-exponent 2)) (bytevector-div frac (* 256 256))))
              (c-u8-set! pointer (+ k 1) (bytevector-div (bytevector-mod frac (* 256 256)) 256))
              (c-u8-set! pointer (+ k 0) (bytevector-mod frac 256))))
          (unspecified))
        (cond ((= biased-exponent bytevector-single-maxexponent)
               (store! sign biased-exponent frac))
              ((< frac bytevector-single-hidden-bit)
               (store! sign 0 frac))
              (else (store! sign biased-exponent (- frac bytevector-single-hidden-bit))))))))

(define (make-ieee-single sign biased-exponent bits)
  (cond ((= biased-exponent bytevector-single-maxexponent)
         (if (zero? bits)
             (if (= 0 sign) +inf.0 -inf.0)
             (if (= 0 sign) +nan.0 -nan.0)))
        ((= 0 biased-exponent)
         (if (= 0 bits)
             (if (= 0 sign) +0.0 -0.0)
             (let* ((x (inexact bits))
                    (two^22 4194304.0)
                    (x (/ x two^22))
                    (x (* x (expt 2.0 (- bytevector-single-bias)))))
               (if (= 0 sign) x (- x)))))
        (else
         (let* ((bits (+ #| hidden bit: |# #x800000 bits))
                (x (inexact bits))
                (two^23 8388608.0)
                (x (/ x two^23))
                (x (* x (expt 2.0 (- biased-exponent bytevector-single-bias)))))
           (if (= 0 sign) x (- x))))))

(define (c-bytevector-ieee-single-ref cbv k)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-ieee-single-ref: cbv must be c-bytevector" cbv))
  (let ((pointer (c-bytevector-pointer cbv)))
    (cond ((symbol=? endianness 'little)
           (let* ((byte0 (c-u8-ref pointer (+ k 3)))
                  (byte1 (c-u8-ref pointer (+ k 2)))
                  (byte2 (c-u8-ref pointer (+ k 1)))
                  (byte3 (c-u8-ref pointer (+ k 0)))
                  (sign (quotient byte0 128))
                  (biased-exponent (+ (* 2 (remainder byte0 128))
                                      (quotient byte1 128)))
                  (bits (+ (* 65536 (remainder byte1 128))
                           (* 256 byte2)
                           byte3)))
             (make-ieee-single sign biased-exponent bits)))
          ((symbol=? endianness 'big)
           (let* ((byte0 (c-u8-ref pointer (+ k 0)))
                  (byte1 (c-u8-ref pointer (+ k 1)))
                  (byte2 (c-u8-ref pointer (+ k 2)))
                  (byte3 (c-u8-ref pointer (+ k 3)))
                  (sign (quotient byte0 128))
                  (biased-exponent (+ (* 2 (remainder byte0 128))
                                      (quotient byte1 128)))
                  (bits (+ (* 65536 (remainder byte1 128))
                           (* 256 byte2)
                           byte3)))
             (make-ieee-single sign biased-exponent bits)))
          (else (error "Unknown endianness" endianness)))))

(define (c-bytevector-ieee-double-set! cbv k x)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-ieee-double-set!: cbv must be c-bytevector" cbv))
  (let ((pointer (c-bytevector-pointer cbv)))
    (call-with-values
      (lambda ()
        (bytevector-ieee-parts x bytevector-double-bias bytevector-double-hidden-bit))
      (lambda (sign biased-exponent frac)

        (define (store! sign biased-exponent frac)
          (c-u8-set! pointer (+ k 7) (+ (* 128 sign) (bytevector-div biased-exponent 16)))
          (c-u8-set! pointer (+ k 6) (+ (* 16 (bytevector-mod biased-exponent 16)) (bytevector-div frac two^48)))
          (c-u8-set! pointer (+ k 5) (bytevector-div (bytevector-mod frac two^48) two^40))
          (c-u8-set! pointer (+ k 4) (bytevector-div (bytevector-mod frac two^40) two^32))
          (c-u8-set! pointer (+ k 3) (bytevector-div (bytevector-mod frac two^32) two^24))
          (c-u8-set! pointer (+ k 2) (bytevector-div (bytevector-mod frac two^24) two^16))
          (c-u8-set! pointer (+ k 1) (bytevector-div (bytevector-mod frac two^16) 256))
          (c-u8-set! pointer (+ k 0) (bytevector-mod frac 256))
          (if (not (eq? endianness 'little))
            (begin (swap! (+ k 0) (+ k 7))
                   (swap! (+ k 1) (+ k 6))
                   (swap! (+ k 2) (+ k 5))
                   (swap! (+ k 3) (+ k 4))))
          (unspecified))

        (define (swap! i j)
          (let ((bi (c-u8-ref pointer i))
                (bj (c-u8-ref pointer j)))
            (c-u8-set! pointer i bj)
            (c-u8-set! pointer j bi)))

        (cond ((= biased-exponent bytevector-double-maxexponent)
               (store! sign biased-exponent frac))
              ((< frac bytevector-double-hidden-bit)
               (store! sign 0 frac))
              (else
                (store! sign biased-exponent
                        (- frac bytevector-double-hidden-bit))))))))

(define (make-ieee-double sign biased-exponent hibits midbits lobits)
  (cond ((= biased-exponent bytevector-double-maxexponent)
         (if (zero? (+ hibits midbits lobits))
             (if (= 0 sign)
                 +inf.0
                 -inf.0)
             (if (= 0 sign)
                 +nan.0
                 -nan.0)))
        ((= 0 biased-exponent)
         (if (and (= 0 hibits)
                  (= 0 midbits)
                  (= 0 lobits))
             (if (= 0 sign)
                 +0.0
                 -0.0)
             (let* ((x (inexact hibits))
                    (x (+ (* 65536.0 x)
                          (inexact midbits)))
                    (x (+ (* 65536.0 x)
                          (inexact lobits)))
                    (two^51 2.251799813685248e15)
                    (x (/ x two^51))
                    (x (* x (expt 2.0 (- bytevector-double-bias)))))
               (if (= 0 sign)
                   x
                   (- x)))))
        (else
         (let* ((hibits (+ #x100000    ; hidden bit
                           hibits))
                (x (inexact hibits))
                (x (+ (* 65536.0 x)
                      (inexact midbits)))
                (x (+ (* 65536.0 x)
                      (inexact lobits)))
                (two^52 4.503599627370496e15)
                (x (/ x two^52))
                (x (* x (expt 2.0
                              (- biased-exponent bytevector-double-bias)))))
           (if (= 0 sign)
               x
               (- x))))))

(define (c-bytevector-ieee-double-ref cbv k)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-ieee-double-ref: cbv must be c-bytevector" cbv))
  (let ((pointer (c-bytevector-pointer cbv)))
    (cond
      ((symbol=? endianness 'little)
       (let* ((byte0 (c-u8-ref pointer (+ k 7)))
              (byte1 (c-u8-ref pointer (+ k 6)))
              (byte2 (c-u8-ref pointer (+ k 5)))
              (byte3 (c-u8-ref pointer (+ k 4)))
              (byte4 (c-u8-ref pointer (+ k 3)))
              (byte5 (c-u8-ref pointer (+ k 2)))
              (byte6 (c-u8-ref pointer (+ k 1)))
              (byte7 (c-u8-ref pointer (+ k 0)))
              (sign (quotient byte0 128))
              (biased-exponent (+ (* 16 (remainder byte0 128))
                                  (quotient byte1 16)))
              (hibits (+ (* 65536 (remainder byte1 16))
                         (* 256 byte2)
                         byte3))
              (midbits (+ (* 256 byte4) byte5))
              (lobits (+ (* 256 byte6) byte7)))
         (make-ieee-double sign biased-exponent hibits midbits lobits)))
      ((symbol=? endianness 'big)
       (let* ((byte0 (c-u8-ref pointer (+ k 0)))
              (byte1 (c-u8-ref pointer (+ k 1)))
              (byte2 (c-u8-ref pointer (+ k 2)))
              (byte3 (c-u8-ref pointer (+ k 3)))
              (byte4 (c-u8-ref pointer (+ k 4)))
              (byte5 (c-u8-ref pointer (+ k 5)))
              (byte6 (c-u8-ref pointer (+ k 6)))
              (byte7 (c-u8-ref pointer (+ k 7)))
              (sign (quotient byte0 128))
              (biased-exponent (+ (* 16 (remainder byte0 128))
                                  (quotient byte1 16)))
              (hibits (+ (* 65536 (remainder byte1 16))
                         (* 256 byte2)
                         byte3))
              (midbits (+ (* 256 byte4) byte5))
              (lobits (+ (* 256 byte6) byte7)))
         (make-ieee-double sign biased-exponent hibits midbits lobits)))
      (else (error "Unknown endianness" endianness)))))
;; From (r6rs bytevectors) library end

(define make-c-bytevector
  (lambda (size . byte)
    (when (not (integer? size))
      (error "make-c-bytevector: Size must be integer" size))
    (let ((cbv (cond ((null? byte) (c-malloc size))
                     ((= (car byte) 0) (c-calloc 1 size))
                     (else (bytevector->c-bytevector (make-bytevector size (car byte)))))))
      #;(when (= (c-memset-pointer->address pointer 0 0) 0)
        (c-perror (c-bytevector-pointer (string->c-bytevector "make-c-bytevector error")))
        (error "make-c-bytevector error: malloc returned null" size))
      ;(internal-make-c-bytevector pointer)
      cbv)))

(define (c-bytevector-free cbv)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector-free: cbv must be c-bytevector" cbv))
  (c-free (c-bytevector-pointer cbv)))

(define (c-bytevector-null)
  (let ((null-cbv (c-null)))
    (if (c-bytevector? null-cbv)
      null-cbv
      (internal-make-c-bytevector (c-null)))))

(define (c-bytevector-null? cbv)
  (and (c-bytevector? cbv)
       (c-null? (c-bytevector-pointer cbv))))

(define c-bytevector
  (lambda bytes
    (bytevector->c-bytevector
      (apply (lambda (b) (make-bytevector 1 b)) bytes))))

(define (c-bytevector-set! cbv type offset/member value)
  (cond
    ((not (c-bytevector? cbv))
     (error "c-bytevector-set!: cbv argument must be c-bytevector" cbv))
    ((and (not (c-struct-type? type))
          (not (exact-integer? offset/member)))
     (error "c-bytevector-set!: offset/member argument must be exact integer" offset/member))
    ((and (c-struct-type? type)
          (not (symbol? offset/member)))
     (error "c-bytevector-set!: offset/member argument must be symbol" offset/member)))
  (cond
    ((and (c-integer-type? type)
          (c-integer-type-signed? type))
     (when (not (exact-integer? value))
       (error "c-bytevector-set!: for c-integer-type value must be exact integer" value))
     (c-bytevector-uint-set! cbv offset/member value (c-type-size type)))
    ((and (c-integer-type? type)
          (not (c-integer-type-signed? type)))
     (when (not (exact-integer? value))
       (error "c-bytevector-set!: for c-integer-type value must be exact integer" value))
     (when (not (or (positive? value)
                    (zero? value)))
       (error "c-bytevector-set!: for unsigned c-integer-type value must be positive exact integer or 0" value))
     (c-bytevector-sint-set! cbv offsett/member value (c-type-size type)))
    ((c-float-type? type)
     (c-bytevector-ieee-single-set! cbv offset/member (c-type-size type)))
    ((c-struct-type? type)
     (let* ((memb (internal-c-struct-type-member type offset/member))
            (type (list-ref memb 1))
            (offset (list-ref memb 2)))
       (c-bytevector-set! cbv type offset value)))
    (else (error "c-bytevector-set!: type must be any C type" type)))
  #;(cond ((not (symbol? type)) (error "c-bytevector-set!: type must be symbol" type))
        ((symbol=? type 'i8)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'i8)))
        ((symbol=? type 'u8)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-u8-set! (c-bytevector-pointer cbv) offset value))
        ((symbol=? type 'i16)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'i16)))
        ((symbol=? type 'u16)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'u16)))
        ((symbol=? type 'i32)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value 4))
        ((symbol=? type 'u32)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-uint-set! cbv offset value 4))
        ((symbol=? type 'i64)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value 8))
        ((symbol=? type 'u64)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-uint-set! cbv offset value 8))
        ((symbol=? type 'char)
         (when (not (char? value))
           (error "c-bytevector-set!: value for given type must be char"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset (char->integer value) (c-type-size 'i8)))
        ((symbol=? type 'uchar)
         (when (not (char? value))
           (error "c-bytevector-set!: value for given type must be char"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-uint-set! cbv offset (char->integer value) (c-type-size 'u8)))
        ((symbol=? type 'short)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'short)))
        ((symbol=? type 'ushort)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'ushort)))
        ((symbol=? type 'int)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'int)))
        ((symbol=? type 'uint)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'uint)))
        ((symbol=? type 'long)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'long)))
        ((symbol=? type 'ulong)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-sint-set! cbv offset value (c-type-size 'ulong)))
        ((symbol=? type 'float)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-ieee-single-set! cbv offset value))
        ((symbol=? type 'double)
         (when (not (number? value))
           (error "c-bytevector-set!: value for given type must be number"
                  `((type ,type)
                    (value ,value))))
         (c-bytevector-ieee-double-set! cbv offset value))
        ((symbol=? type 'pointer)
         (when (not (c-bytevector? value))
           (error "c-bytevector-set!: value for given type must be c-bytevector"
                  `((type ,type)
                    (value ,value))))
         (c-pointer-set! (c-bytevector-pointer cbv)
                         offset
                         (c-bytevector-pointer value)))
        (else (error "c-bytevector-set!: Unknown type" type))))

(define (c-bytevector-ref cbv type offset/member)
  (cond
    ((not (c-bytevector? cbv))
     (error "c-bytevector-ref: cbv argument must be c-bytevector" cbv))
    ((and (not (c-struct-type? type))
          (not (exact-integer? offset/member)))
     (error "c-bytevector-ref: offset/member argument must be exact integer" offset))
    ((and (c-struct-type? type)
          (not (symbol? offset/member)))
     (error "c-bytevector-set!: offset/member argument must be symbol" offset/member)))
  (cond
    ((and (c-integer-type? type) (c-integer-type-signed? type))
     (c-bytevector-sint-ref cbv offset/member (c-integer-type-size type)))
    ((and (c-integer-type? type) (not (c-integer-type-signed? type)))
     (c-bytevector-uint-ref cbv offset/member (c-integer-type-size type)))
    ((c-float-type? type)
     (c-bytevector-ieee-single-ref cbv offset/member))
    ((c-struct-type? type)
     (let* ((memb (internal-c-struct-type-member type offset/member))
            (type (list-ref memb 1))
            (offset (list-ref memb 2)))
       (c-bytevector-ref cbv type offset)))
    (else (error "c-bytevector-ref: type must be any C type" type)))
  #;(cond ((symbol=? type 'i8) (c-bytevector-sint-ref cbv offset 1))
        ((symbol=? type 'u8) (c-bytevector-uint-ref cbv offset 1))
        ((symbol=? type 'i16) (c-bytevector-sint-ref cbv offset 2))
        ((symbol=? type 'u16) (c-bytevector-uint-ref cbv offset 2))
        ((symbol=? type 'i32) (c-bytevector-sint-ref cbv offset 4))
        ((symbol=? type 'u32) (c-bytevector-uint-ref cbv offset 4))
        ((symbol=? type 'i64) (c-bytevector-sint-ref cbv offset 8))
        ((symbol=? type 'u64) (c-bytevector-uint-ref cbv offset 8))
        ((symbol=? type 'char) (integer->char (c-bytevector-sint-ref cbv offset 1)))
        ((symbol=? type 'uchar) (integer->char (c-bytevector-uint-ref cbv offset 1)))
        ((symbol=? type 'short) (c-bytevector-sint-ref cbv offset (c-type-size 'short)))
        ((symbol=? type 'ushort) (c-bytevector-uint-ref cbv offset (c-type-size 'ushort)))
        ((symbol=? type 'int) (c-bytevector-sint-ref cbv offset (c-type-size 'int)))
        ((symbol=? type 'uint) (c-bytevector-uint-ref cbv offset (c-type-size 'uint)))
        ((symbol=? type 'long) (c-bytevector-sint-ref cbv offset (c-type-size 'long)))
        ((symbol=? type 'ulong) (c-bytevector-uint-ref cbv offset (c-type-size 'ulong)))
        ((symbol=? type 'float) (c-bytevector-ieee-single-ref cbv offset))
        ((symbol=? type 'double) (c-bytevector-ieee-double-ref cbv offset))
        ((equal? type 'pointer) (internal-make-c-bytevector (c-pointer-ref (c-bytevector-pointer cbv) offset)))
        (else (error "c-bytevector-ref: Unknown type" type))))

(define (bytevector->c-bytevector bv)
  (when (not (bytevector? bv))
    (error "bytevector->c-bytevector: bv argument must be bytevector" bv))
  (letrec* ((bytes-length (bytevector-length bv))
            ;; Kawa gets stuck compiling if make-c-bytevector is used here
            (cbv (c-malloc bytes-length))
            (looper (lambda (index)
                      (when (< index bytes-length)
                        (c-u8-set! (c-bytevector-pointer cbv) index (bytevector-u8-ref bv index))
                        (looper (+ index 1))))))
    (looper 0)
    cbv))

(define (c-bytevector->bytevector cbv size)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector->bytevector: cbv argument must be c-bytevector" cbv))
  (when (not (integer? size))
    (error "c-bytevector->bytevector: size argument must be integer" size))
  (letrec* ((bv (make-bytevector size))
            (looper (lambda (index)
                      (let ((byte (c-u8-ref (c-bytevector-pointer cbv) index)))
                        (cond ((= index size) bv)
                              (else (bytevector-u8-set! bv index byte)
                                    (looper (+ index 1))))))))
    (looper 0)))

(define (c-bytevector->string cbv)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector->string: cbv argument must be c-bytevector" cbv))
  (let ((size (c-strlen (c-bytevector-pointer cbv))))
    (utf8->string (c-bytevector->bytevector cbv size))))

(define (string->c-bytevector str)
  (when (not (string? str))
    (error "string->c-bytevector: str argument must be string" str))
  (bytevector->c-bytevector
    (string->utf8
      (string-append str (string (integer->char 0))))))

(define (c-bytevector->integer cbv . offset)
  (when (not (c-bytevector? cbv))
    (error "c-bytevector->integer cbv argument must be c-bytevector" cbv))
  (let ((internal-offset (if (null? offset) 0 (car offset))))
    (when (not (integer? internal-offset))
      (error "c-bytevector->integer offset argument must be integer" (car offset)))
    (+ (c-memset-pointer->address (c-bytevector-pointer cbv) 0 0) internal-offset)))

(define (integer->c-bytevector address)
  (when (not (integer? address))
    (error "c-bytevector->string: address argument must be integer" address))
  (c-memset-address->pointer address 0 0))

(define (c-bytevector->list cbv type)
  (cond
    ((not (c-bytevector? cbv))
     (error "c-struct->alist: cbv must be c-bytevector" cbv))
    ((c-struct-type? type)
     (map
       (lambda (memb)
         (cons (car memb) (c-bytevector-ref cbv type (car memb))))
       (c-struct-type-members type)))
    (else
      (error "c-bytevector->list: dont know how to make list of type yet" type))))
